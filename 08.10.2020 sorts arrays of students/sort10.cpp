#include "sorts.h"


static void restore_struct (Student arr[], int k)
{
	int i;
	
	i = 0;
	while (i < (k-1)/2)
    {
		//arr[i] <= child1 >= child2.
        if ( (arr[i] <= arr[(i*2)+1]) && (arr[(i*2)+1] >= arr[(i*2)+2]) )
        {
            arr[i].swap (arr[(i*2)+1]);
            i = (i*2)+1;
        }
        else 
        {
			// arr[i] <= child2 >= child1.
            if ( (arr[i] <= arr[(i*2)+2]) && (arr[(i*2)+1] <= arr[(i*2)+2]) )
            {
                arr[i].swap (arr[(i*2)+2]);
                i = (i*2)+2;
            }
            else 
                i = k;
        }
    }
}

void sort10 (Student arr[], int n)
{
    int i, j, k;
    //Родитель это (cur-1)/2.
	//Потомки cur*2+1, cur*2+2
	
	
    //Первый этап.
    //Делаем упорядоченную пирамиду (потомок > родителя).
	//Для этого продвигаем "бОльших" потомков в сторону корня подобно тому,
	//как это было в линейной вставке.
	
	for (i = 1; i < n; i++)
    {
        k = i;
        for (j = (i-1)/2; j > 0; j=(j-1)/2)
        {
            if (arr[j] < arr[k])
            {
                arr[j].swap(arr[k]);
                k = j;
            }
        }
		if (arr[0] < arr[k])
            arr[k].swap (arr[0]);
    }
	
	// Второй этап.
	// Для всех k=n-1,...,1: меняем корень (a[0]) и элемент a[k]
	// местами и рассматриваем массив a как имеющий длину k.
	// В этом массиве восстанавливаем структуру упорядоченной пирамиды,
	// нарушенную  помещением a[k] в a[0]. Для этого идём от a[0] по цепочкам
	// его потомков, продвигая на своё место (подобно линейной вставке с
	// тем отличием, что этот элемент должен быть больше обоих своих потомков).
	for (k = n-1; k > 0; k--)
    {
        arr[k].swap (arr[0]);
        restore_struct (arr, k);
    }
	
    if ((n > 1) && (arr[1] < arr[0]))
    {
		arr[0].swap(arr[1]);
    }
}
